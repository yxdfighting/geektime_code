## 学习总结
### 链表
1.  所有的链表题目的基本框架都是链表从头到尾的遍历，不同的是各个题目对于遍历过程中每个链表node的操作不同
    for (head != nil){} 按照这种方式，可以遍历到链表的每一个节点  
2.  在有些情况下，为了保证遍历过程中处理每个节点的逻辑统一，比如反转链表，需要将每个节点指向其前缀，但是对于头节点来说，不存在头节点的前缀，此时可以用一个保护节点，也叫哑节点，
    指向链表的头节点，这样在程序实现中就不需要单独处理头节点前缀的问题。
    
    在golang中，要注意，在新开辟一个链表节点时，var pro *ListNode,此时pro的值为nil，是指针的零值；pro := &ListNode{},此时相当于对结构体进行初始化，pro存储的是一个指向ListNode类型的指针，
    该ListNode的Val为0，Next为nil
3.  在链表中，细节部分的处理，在遍历过程中，很容易遇到某个节点是nil，然后再对其取Next，这时候程序会抛出异常panic
4.  在很多时候，对节点的后继节点操作或者前缀节点操作时，需要在修改前先临时保存一下对应的节点地址

### 数组
1.  各个语言中的变长数组实现基本逻辑，以golang为例,即slice，其实新手在使用时有一些坑，这里就不写了。
    主要写一下其扩容和缩容的逻辑：扩容的前提是length超过cap，以1024长度为分界线，在1024以前，每次扩容2倍，然后将原来内存地址的元素复制到扩容后新的地址
    在1024以后，每次扩容为1.25倍
    
    缩容：在课上讲到Cpp语言，是按照25%的利用率为界限，每次到达25%利用率临界区时，整体缩容一半；在golang中，暂时没有找到相关的介绍，此处留一个todo
2.  在数组题中，之前一直有一个误区，认为插入和删除某个元素，就一定要涉及到元素的批量移动，所以之前每次都搞得复杂度很尴尬。
    其实是一个技巧或者思路转换问题，比如在删除有序数组中的重复项这个题目中，遍历每个元素如果跟前一个相同，之前直观的想法是删除前一个元素，其实也就是所有元素向前移动一位
    其实这样是时间复杂度非常高的，整体算下来是个O(n2),这种情况下，我们可以用一个新的index来表示，在遍历过程中，如果遇到某个元素跟前一个元素不同时，index++;如果相同时，就不变
    用一个新的index来表示结果。
3.  在用新的index表示结果时，要注意不能覆盖掉数组中还没有使用过的元素索引，在遇到这种情况时，可以考虑从后向前遍